#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <cassert>
#include <cmath>
#include <vector>
#include <algorithm>
#include <iostream>

template<class T> class SparseVector{
private:
	//Add your data members here!
	unsigned int mSize;  // total length of the sparse vector
	std::vector<unsigned int> mIndices;  // indices of stored non-zero values
	std::vector<T> mValues;  // stored non-zero values

public:
	//creates an empty vector of dimensionality 0.
	SparseVector(){
		mSize = 0;
	}

	// Creates a vector of dimensionality dim. It starts with 0 non-zero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim){
		mSize = dim;
	}

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added
	void setValue(unsigned int index, T value){
		auto findResult = std::find(mIndices.begin(), mIndices.end(), index);

		if(findResult != mIndices.end()){  // the given index already points to a non-zero value
			unsigned int posA = std::lower_bound(mIndices.begin(), mIndices.end(), index) - mIndices.begin();
			mValues[posA] = value;  // change the pointed value; the mIndices will not be changed
		}
		else{  // the given index does not point to a non-zero value
			auto posB = std::lower_bound(mIndices.begin(), mIndices.end(), index);
			auto posC = posB - mIndices.begin() + mValues.begin();
			mIndices.insert(posB, index);
			mValues.insert(posC, value);  // cannot use posB directly or re use it

			if(index >= mSize){
				mSize = index + 1;
			}
		}
	}

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const{
		assert(index < mSize);

		auto findResult = std::find(mIndices.begin(), mIndices.end(), index);
		if(findResult != mIndices.end()){  // the given index points to a non-zero value
			unsigned int posA = std::lower_bound(mIndices.begin(), mIndices.end(), index) - mIndices.begin();
			return mValues[posA];
		}
		else{
			return 0;
		}
	}

	//returns the dimensionality of the vector
	unsigned int size() const{
		return mSize;
	}

	// returns the number of stored non-zero elements
	unsigned int nonZeroes() const{
		return mIndices.size();
	}

	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const{
		assert(i < mIndices.size());
		return mIndices[i];
	}

	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const{
		assert(i < mValues.size());
		return mValues[i];
	}

	//adds sparse vector x to the current sparse vector
	SparseVector<T>& operator+= (SparseVector<T> const& x){
		assert(mSize == x.mSize);
		for(unsigned int i = 0; i < x.nonZeroes(); i++){
			auto findResult = std::find(mIndices.begin(), mIndices.end(), x.indexNonZero(i));

			if(findResult != mIndices.end()){  // both sparse vectors store a non-zero value here
				unsigned int posA = std::lower_bound(mIndices.begin(), mIndices.end(), x.indexNonZero(i)) - mIndices.begin();
				mValues[posA] += x.valueNonZero(i);
			}
			else{  // the first sparse vector does not store a non-zero value here, but the second does
				auto posB = std::lower_bound(mIndices.begin(), mIndices.end(), x.indexNonZero(i));
				auto posC = posB - mIndices.begin() + mValues.begin();
				mIndices.insert(posB, x.indexNonZero(i));
				mValues.insert(posC, x.valueNonZero(i));  // cannot use posB directly or re use it
			}
		}
		return *this;
	}

	//subtracts sparse vector x from the current sparse vector vector
	SparseVector<T>& operator-= (SparseVector<T> const& x){
		assert(mSize == x.mSize);
		for(unsigned int i = 0; i < x.nonZeroes(); i++){
			auto findResult = std::find(mIndices.begin(), mIndices.end(), x.indexNonZero(i));

			if(findResult != mIndices.end()){  // both sparse vectors store a non-zero value here
				unsigned int posA = std::lower_bound(mIndices.begin(), mIndices.end(), x.indexNonZero(i)) - mIndices.begin();
				mValues[posA] -= x.valueNonZero(i);
			}
			else{  // the first sparse vector does not store a non-zero value here, but the second does
				auto posB = std::lower_bound(mIndices.begin(), mIndices.end(), x.indexNonZero(i));
				auto posC = posB - mIndices.begin() + mValues.begin();
				mIndices.insert(posB, x.indexNonZero(i));
				mValues.insert(posC, -x.valueNonZero(i));  // cannot use posB directly or re use it
			}
		}
		return *this;
	}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){
	assert(x.size() == y.size());
	SparseVector<T> z(x);
	z += y;
	return z;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
	assert(x.size() == y.size());
	SparseVector<T> z(x);
	z -= y;
	return z;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){
	assert(A.GetNumberOfColumns() == x.size());
	Vector<T> resultVector(A.GetNumberOfRows());

	for(unsigned int i = 0; i < A.GetNumberOfRows(); i++){
		for (unsigned int j = 0; j < x.size(); j++){
			resultVector[i] += A(i,j) * x.getValue(j);
		}
	}
	return resultVector;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A){
	assert(A.GetNumberOfRows() == x.size());
	Vector<T> resultVector(A.GetNumberOfColumns());

	for(unsigned int i = 0; i < A.GetNumberOfColumns(); i++){
		for (unsigned int j = 0; j < x.size(); j++){
			resultVector[i] += x.getValue(j) * A(j,i);
		}
	}
	return resultVector;
}

#endif
